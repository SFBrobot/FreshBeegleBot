#pragma config(Motor,  port1,           BLWheel,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FLWheel,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           TRArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           BRArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BLArm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           TLArm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           RClaw,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           FRWheel,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BRWheel,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"

/*

*******************************************
	        __   ___  ______      ______
	      /  /  /  / /  __  \   /   _   \
	     /  / /  /  /  /  |_|  /   / |  |
	    /  //  /   |  |___    /   /_/  /
	   /     /     \___   \  /   ____ /
	  /  /|  |   ___   \  | /   /
	 /  / |  |   \  \_/  / /   /
	/__/  |__|    \_____/ /___/

*******************************************

*/


//SOUND TASK: CALLED IN DRIVERCONTROL TASK
task speaker_sound(){
	while(true){
		playSoundFile("sandstormUse.wav");//Sound clip
		wait1Msec(670);//Length of sound clip
	}
}


//USER CONTROL FUNCTIONS

//Sets Drive
void setDriveL(int pwr) {
	motor[FLWheel] =
		motor[BLWheel] =
		pwr;
}

void setDriveR(int pwr) {
	motor[FRWheel] =
		motor[BRWheel] =
		pwr;
}

//Drive options
void arcade(int move, int rot) {
	setDriveL(move + rot);
	setDriveR(move - rot);
}

void tank(int pwrL, int pwrR) {
	setDriveL(pwrL);
	setDriveR(pwrR);
}

//Arm Function
void setArm(int pwr) {
	motor[TRArm] = motor[TLArm] = motor[BRArm] = motor[BLArm] = (pwr);
}

//Claw Functions
void setClaw(int pwr) {
	motor[RClaw] = motor[LClaw] = (pwr);
}


//AUTON FUNCTIONS

//Wheel Auton function
void goRobit(int lpwr, int rpwr, int time){
	motor[BLWheel] = motor[FRWheel] = (lpwr);
	motor[FRWheel] = motor[BRWheel] = (rpwr);
	wait1Msec(time);
	motor[BLWheel] = motor[FLWheel] = motor[FRWheel] = motor[BRWheel] = 0;
}

//Arm Auton function
void goArm(int pwr, int time){
	motor[TLArm] = motor[TRArm] = motor[BLArm] = motor[BRArm] = -(pwr);
	wait1Msec(time);
	motor[TLArm] = motor[TRArm] = motor[BLArm] = motor[BRArm] = 0;
}

//Claw Auton function
void goClaw(int pwr, int time){
	motor[LClaw] = motor[RClaw] = (pwr);
	wait1Msec(time);
	motor[LClaw] = motor[RClaw] = 0;
}


//Do not edit unless you know what you are doing to it
void pre_auton()
{

}


//AUTON PROGRAM
task autonomous() {
goRobit(127, 127, 1000);
goArm(127, 250);
goRobit(127, -127, 900);
goRobit(127, 127, 500);
goClaw(127, 1500);
goRobit(-127, -127, 2000);
goArm(127, 2500);
}


//USER CONTROL PROGRAM
task usercontrol() {
	startTask (speaker_sound);//Plays sound clip
	while(true) {

		//Drive Control
		arcade(vexRT[Ch3], vexRT[Ch4]);

		//Arm Control
		if(vexRT[Btn5D]){
			setArm(-127);
		}
		else if(vexRT[Btn5U]){
			setArm(127);
		}
		else {
			setArm(0);
		}

		//Claw Control
		if(vexRT[Btn6D]) {
			setClaw(-127);
		}
		else if(vexRT[Btn6U]) {
			setClaw(127);
		}
		else {
			setClaw(0);
		}
		wait1Msec(20); //Allows cortex to finish backlog of commands
	}
}
