#pragma config(Motor,  port1,           BLWheel,       tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           FLWheel,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           TRArm,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           BRArm,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BLArm,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           TLArm,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           RClaw,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LClaw,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           FRWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BRWheel,       tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"

/*

*******************************************
	        __   ___  ______      ______
	      /  /  /  / /  __  \   /   _   \
	     /  / /  /  /  /  |_|  /   / |  |
	    /  //  /   |  |___    /   /_/  /
	   /     /     \___   \  /   ____ /
	  /  /|  |   ___   \  | /   /
	 /  / |  |   \  \_/  / /   /
	/__/  |__|    \_____/ /___/

*******************************************

*/


//SOUND TASK: CALLED IN DRIVERCONTROL TASK
task speaker_sound(){
	while(true){
		playSoundFile("sandstormUse.wav");//Sound clip
		wait1Msec(670);//Length of sound clip
	}
}


//USER CONTROL FUNCTIONS

//Sets drive motors
void setDriveL(int pwr) {
	motor[FLWheel] =
		motor[BLWheel] =
		pwr;
}

void setDriveR(int pwr) {
	motor[FRWheel] =
		motor[BRWheel] =
		pwr;
}

//Drive options
void arcade(int move, int rot) {
	setDriveL(move + rot);
	setDriveR(move - rot);
}

void tank(int pwrL, int pwrR) {
	setDriveL(pwrL);
	setDriveR(pwrR);
}

//Arm Function
void setArm(int pwr) {
	motor[TRArm] = motor[TLArm] = motor[BRArm] = motor[BLArm] = (pwr);
}

//Claw Function
void setClaw(int pwr) {
	motor[RClaw] = motor[LClaw] = (pwr);
}


//AUTON FUNCTIONS

//Wheel Auton function
void goRobit(int lpwr, int rpwr, int time){
	motor[BLWheel] = motor[FRWheel] = (lpwr);
	motor[FRWheel] = motor[BRWheel] = (rpwr) - 37;//Robit used to turn to the left during auton. This fixes this (hopefully)!
	wait1Msec(time);
	motor[BLWheel] = motor[FLWheel] = motor[FRWheel] = motor[BRWheel] = 0;
}

//Arm Auton function
void goArm(int pwr, int time){
	motor[TLArm] = motor[TRArm] = motor[BLArm] = motor[BRArm] = (pwr);
	wait1Msec(time);
	motor[TLArm] = motor[TRArm] = motor[BLArm] = motor[BRArm] = 0;
}

//Claw Auton function
void goClaw(int pwr, int time){
	motor[LClaw] = motor[RClaw] = (pwr);
	wait1Msec(time);
	motor[LClaw] = motor[RClaw] = 0;
}


//Do not edit unless you know what you are doing to it
void pre_auton()
{

}


//AUTON PROGRAM
task autonomous() {
goRobit(127, 127, 1000);//Robit forward
goRobit(127, -127, 750);//Robit turns towards star on right
goRobit(127, 127, 550);//Robit forward in preperation to grab star
goClaw(127, 1650);//Claw closes to grab star
goRobit(127, -127, 500);//Robit turns
goRobit(-127, -127, 2000);//Robit back towards fence
goArm(127, 1650);//Arm up over fence
goClaw(-127, 600);//Star drops onto other side
goArm(-127, 1600);//Arm down
goRobit(127, 127, 1500);//Robit forward
goRobit(127, -127, 600);//Robit turns towards cube
goRobit(127, 127, 850);//Robit forwards towards cube
goClaw(127, 1500);//Claw closes on cube
goRobit(-127, 127, 2000);//Robit turns, back towards fence
goRobit(-127, -127, 750);//Robit backwards
goArm(127, 1750);//Arm up, cube over fence
goClaw(-127, 600);//Claw opens, cube drops
goArm(-127, 1600);//Arm back down
goClaw(127, 250);//Claw closes partially, prep for driver control
goRobit(127, 127, 500);//Robit forward, prep for driver control
}


//USER CONTROL PROGRAM
task usercontrol() {
	startTask(speaker_sound);
	int stick[4] = { 0, 0, 0, 0 };//Array for killing motor whine
	while(true) {

		for(int i = 0; i < 4; i++) {//Completly ANNIHALATES annoying motor whine (like a bug!)
			if(fabs(vexRT[i]) > 15)
				stick[i] = vexRT[i];
			else
				stick[i] = 0;
		}

		//Drive Control
	  arcade(vexRT[Ch3], vexRT[Ch4]);

		//Arm Control
    if(vexRT[Btn5D]){
		  setArm(-127);
    }
    else if(vexRT[Btn5U]){
		  setArm(127);
    }
    else {
      setArm(0);
    }

		//Claw Control
    if(vexRT[Btn6D]) {
		  setClaw(-127);
    }
    else if(vexRT[Btn6U]) {
		  setClaw(127);
    }
    else {
	 		setClaw(0);
    }

		wait1Msec(20); //Allows cortex to finish backlog of commands
  }
}
